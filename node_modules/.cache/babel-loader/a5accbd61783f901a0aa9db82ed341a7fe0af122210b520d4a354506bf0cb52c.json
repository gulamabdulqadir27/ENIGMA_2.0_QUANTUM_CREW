{"ast":null,"code":"// feat: CSV parsing and real EEG data analysis logic\n// Handles raw text processing and approximate spectral analysis\n\nimport { computeRiskScore, classifyRisk, generateSHAPValues, computeCoherence } from \"./eegUtils\";\n\n/**\r\n * Parses raw CSV text into an array of signal points.\r\n * Expected columns: time, Fp1, F3, C3, P3, O1\r\n */\nexport function parseCSV(text) {\n  const lines = text.trim().split(/\\r?\\n/);\n  if (lines.length < 2) throw new Error(\"File is empty or too short.\");\n  const headers = lines[0].split(\",\").map(h => h.trim());\n  const required = [\"time\", \"Fp1\", \"F3\", \"C3\", \"P3\", \"O1\"];\n  required.forEach(col => {\n    if (!headers.includes(col)) throw new Error(`Missing required column: ${col}`);\n  });\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(\",\");\n    if (values.length < headers.length) continue;\n    const point = {};\n    headers.forEach((h, idx) => {\n      point[h] = parseFloat(values[idx]);\n    });\n\n    // basic validation: ensure values are numbers\n    if (required.some(h => isNaN(point[h]))) {\n      console.warn(`Invalid numeric data on line ${i + 1}`);\n      continue;\n    }\n    data.push(point);\n  }\n  if (data.length === 0) throw new Error(\"No valid data rows found in CSV.\");\n  return data;\n}\n\n/**\r\n * Heuristic spectral estimation of band powers from a raw signal.\r\n * Maps signal variance and zero-crossing rate to frequency bands.\r\n * No FFT library required.\r\n */\nfunction computeBandPowersFromSignal(signal) {\n  const channels = [\"Fp1\", \"F3\", \"C3\", \"P3\", \"O1\"];\n\n  // Aggregate statistics across all channels\n  let totalVariance = 0;\n  let totalZeroCrossings = 0;\n  channels.forEach(ch => {\n    const values = signal.map(p => p[ch]);\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;\n    totalVariance += variance;\n\n    // compute zero-crossings as frequency proxy\n    let zc = 0;\n    for (let i = 1; i < values.length; i++) {\n      if ((values[i - 1] - mean) * (values[i] - mean) < 0) zc++;\n    }\n    totalZeroCrossings += zc / (signal.length / 256); // normalized to Hz\n  });\n  const avgVariance = totalVariance / channels.length;\n  const avgHz = totalZeroCrossings / channels.length;\n\n  // Heuristically map Hz and Variance to band powers\n  // This is a simplified model for demonstration\n  return {\n    delta: parseFloat((avgVariance * 0.4 * (avgHz < 4 ? 1.5 : 0.8)).toFixed(4)),\n    theta: parseFloat((avgVariance * 0.3 * (avgHz >= 4 && avgHz < 8 ? 1.5 : 0.8)).toFixed(4)),\n    alpha: parseFloat((avgVariance * 0.6 * (avgHz >= 8 && avgHz < 13 ? 1.5 : 0.8)).toFixed(4)),\n    beta: parseFloat((avgVariance * 0.2 * (avgHz >= 13 && avgHz < 30 ? 1.2 : 1)).toFixed(4)),\n    gamma: parseFloat((avgVariance * 0.1 * (avgHz >= 30 ? 1.5 : 1)).toFixed(4))\n  };\n}\n\n/**\r\n * Full analysis pipeline for parsed CSV data.\r\n */\nexport function analyzeCSV(signal) {\n  // 1. Compute band powers from real signal\n  const bandPowers = computeBandPowersFromSignal(signal);\n\n  // 2. Use existing risk scoring logic (we'll use a fixed seed for explainability noise)\n  const analysisSeed = 1337;\n  const {\n    score,\n    confidence,\n    keyMarker,\n    keyDeviation\n  } = computeRiskScore(bandPowers, analysisSeed);\n\n  // 3. Classify and Explain\n  const classification = classifyRisk(score);\n  const isLikelySZ = score > 50; // heuristic for SHAP direction\n  const shapValues = generateSHAPValues(isLikelySZ, analysisSeed);\n  const coherence = computeCoherence(isLikelySZ, analysisSeed);\n  return {\n    riskScore: score,\n    confidence,\n    keyMarker,\n    keyDeviation,\n    classification,\n    eegSignal: signal.slice(0, 1280),\n    // cap to 5s if longer\n    bandPowers,\n    shapValues,\n    coherence\n  };\n}","map":{"version":3,"names":["computeRiskScore","classifyRisk","generateSHAPValues","computeCoherence","parseCSV","text","lines","trim","split","length","Error","headers","map","h","required","forEach","col","includes","data","i","values","point","idx","parseFloat","some","isNaN","console","warn","push","computeBandPowersFromSignal","signal","channels","totalVariance","totalZeroCrossings","ch","p","mean","reduce","a","b","variance","Math","pow","zc","avgVariance","avgHz","delta","toFixed","theta","alpha","beta","gamma","analyzeCSV","bandPowers","analysisSeed","score","confidence","keyMarker","keyDeviation","classification","isLikelySZ","shapValues","coherence","riskScore","eegSignal","slice"],"sources":["C:/Users/gulam/OneDrive/Documents/My Texts/Programming/neuroscan-ai/src/utils/csvAnalysis.js"],"sourcesContent":["// feat: CSV parsing and real EEG data analysis logic\r\n// Handles raw text processing and approximate spectral analysis\r\n\r\nimport {\r\n    computeRiskScore,\r\n    classifyRisk,\r\n    generateSHAPValues,\r\n    computeCoherence,\r\n} from \"./eegUtils\";\r\n\r\n/**\r\n * Parses raw CSV text into an array of signal points.\r\n * Expected columns: time, Fp1, F3, C3, P3, O1\r\n */\r\nexport function parseCSV(text) {\r\n    const lines = text.trim().split(/\\r?\\n/);\r\n    if (lines.length < 2) throw new Error(\"File is empty or too short.\");\r\n\r\n    const headers = lines[0].split(\",\").map(h => h.trim());\r\n    const required = [\"time\", \"Fp1\", \"F3\", \"C3\", \"P3\", \"O1\"];\r\n\r\n    required.forEach(col => {\r\n        if (!headers.includes(col)) throw new Error(`Missing required column: ${col}`);\r\n    });\r\n\r\n    const data = [];\r\n    for (let i = 1; i < lines.length; i++) {\r\n        const values = lines[i].split(\",\");\r\n        if (values.length < headers.length) continue;\r\n\r\n        const point = {};\r\n        headers.forEach((h, idx) => {\r\n            point[h] = parseFloat(values[idx]);\r\n        });\r\n\r\n        // basic validation: ensure values are numbers\r\n        if (required.some(h => isNaN(point[h]))) {\r\n            console.warn(`Invalid numeric data on line ${i + 1}`);\r\n            continue;\r\n        }\r\n\r\n        data.push(point);\r\n    }\r\n\r\n    if (data.length === 0) throw new Error(\"No valid data rows found in CSV.\");\r\n    return data;\r\n}\r\n\r\n/**\r\n * Heuristic spectral estimation of band powers from a raw signal.\r\n * Maps signal variance and zero-crossing rate to frequency bands.\r\n * No FFT library required.\r\n */\r\nfunction computeBandPowersFromSignal(signal) {\r\n    const channels = [\"Fp1\", \"F3\", \"C3\", \"P3\", \"O1\"];\r\n\r\n    // Aggregate statistics across all channels\r\n    let totalVariance = 0;\r\n    let totalZeroCrossings = 0;\r\n\r\n    channels.forEach(ch => {\r\n        const values = signal.map(p => p[ch]);\r\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\r\n        const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;\r\n        totalVariance += variance;\r\n\r\n        // compute zero-crossings as frequency proxy\r\n        let zc = 0;\r\n        for (let i = 1; i < values.length; i++) {\r\n            if ((values[i - 1] - mean) * (values[i] - mean) < 0) zc++;\r\n        }\r\n        totalZeroCrossings += zc / (signal.length / 256); // normalized to Hz\r\n    });\r\n\r\n    const avgVariance = totalVariance / channels.length;\r\n    const avgHz = totalZeroCrossings / channels.length;\r\n\r\n    // Heuristically map Hz and Variance to band powers\r\n    // This is a simplified model for demonstration\r\n    return {\r\n        delta: parseFloat((avgVariance * 0.4 * (avgHz < 4 ? 1.5 : 0.8)).toFixed(4)),\r\n        theta: parseFloat((avgVariance * 0.3 * (avgHz >= 4 && avgHz < 8 ? 1.5 : 0.8)).toFixed(4)),\r\n        alpha: parseFloat((avgVariance * 0.6 * (avgHz >= 8 && avgHz < 13 ? 1.5 : 0.8)).toFixed(4)),\r\n        beta: parseFloat((avgVariance * 0.2 * (avgHz >= 13 && avgHz < 30 ? 1.2 : 1)).toFixed(4)),\r\n        gamma: parseFloat((avgVariance * 0.1 * (avgHz >= 30 ? 1.5 : 1)).toFixed(4)),\r\n    };\r\n}\r\n\r\n/**\r\n * Full analysis pipeline for parsed CSV data.\r\n */\r\nexport function analyzeCSV(signal) {\r\n    // 1. Compute band powers from real signal\r\n    const bandPowers = computeBandPowersFromSignal(signal);\r\n\r\n    // 2. Use existing risk scoring logic (we'll use a fixed seed for explainability noise)\r\n    const analysisSeed = 1337;\r\n    const { score, confidence, keyMarker, keyDeviation } = computeRiskScore(bandPowers, analysisSeed);\r\n\r\n    // 3. Classify and Explain\r\n    const classification = classifyRisk(score);\r\n    const isLikelySZ = score > 50; // heuristic for SHAP direction\r\n    const shapValues = generateSHAPValues(isLikelySZ, analysisSeed);\r\n    const coherence = computeCoherence(isLikelySZ, analysisSeed);\r\n\r\n    return {\r\n        riskScore: score,\r\n        confidence,\r\n        keyMarker,\r\n        keyDeviation,\r\n        classification,\r\n        eegSignal: signal.slice(0, 1280), // cap to 5s if longer\r\n        bandPowers,\r\n        shapValues,\r\n        coherence,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}